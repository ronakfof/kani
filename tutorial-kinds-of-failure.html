<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Failures that Kani can spot - The Kani Rust Verifier</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation for the Kani Rust Verifier">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started with Kani</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="install-guide.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tool-comparison.html"><strong aria-hidden="true">1.2.</strong> Comparison with other tools</a></li><li class="chapter-item expanded "><a href="kani-single-file.html"><strong aria-hidden="true">1.3.</strong> Kani on a single file</a></li><li class="chapter-item expanded "><a href="cargo-kani.html"><strong aria-hidden="true">1.4.</strong> Kani on a package</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.5.</strong> Debugging failures</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.6.</strong> Debugging non-termination</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.7.</strong> Debugging coverage</div></li></ol></li><li class="chapter-item expanded "><a href="kani-tutorial.html"><strong aria-hidden="true">2.</strong> Kani tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial-first-steps.html"><strong aria-hidden="true">2.1.</strong> First steps with Kani</a></li><li class="chapter-item expanded "><a href="tutorial-kinds-of-failure.html" class="active"><strong aria-hidden="true">2.2.</strong> Failures that Kani can spot</a></li><li class="chapter-item expanded "><a href="tutorial-loops-unwinding.html"><strong aria-hidden="true">2.3.</strong> Loops, unwinding, and bounds</a></li><li class="chapter-item expanded "><a href="tutorial-nondeterministic-variables.html"><strong aria-hidden="true">2.4.</strong> Creating non-deterministic variables</a></li><li class="chapter-item expanded "><a href="tutorial-real-code.html"><strong aria-hidden="true">2.5.</strong> Where to start on real code</a></li></ol></li><li class="chapter-item expanded "><a href="dev-documentation.html"><strong aria-hidden="true">3.</strong> Kani developer documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kani-testing.html"><strong aria-hidden="true">3.1.</strong> Testing</a></li><li class="chapter-item expanded "><a href="bookrunner.html"><strong aria-hidden="true">3.2.</strong> Book runner</a></li></ol></li><li class="chapter-item expanded "><a href="limitations.html"><strong aria-hidden="true">4.</strong> Limitations</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Kani Rust Verifier</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/model-checking/kani" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                                        <a href="https://github.com/model-checking/kani/edit/main/kani-docs/src/tutorial-kinds-of-failure.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="failures-that-kani-can-spot"><a class="header" href="#failures-that-kani-can-spot">Failures that Kani can spot</a></h1>
<p>In the <a href="./tutorial-first-steps.html">last section</a> we saw Kani spot two major kinds of failures: assertions and panics.
If the proof harness allows some program trace that results in a panic, then Kani will report that as a failure.
We additionally saw very briefly a couple of other kinds of failures, like null pointer dereferences and overflow.
In this section, we're going to expand on these additional checks, to give you an idea of what other problems Kani will find.</p>
<h2 id="bounds-checking-and-pointers"><a class="header" href="#bounds-checking-and-pointers">Bounds checking and pointers</a></h2>
<p>Rust is safe by default, and so includes dynamic (run-time) bounds checking where needed.
Consider this Rust code (which can be found under <a href="https://github.com/model-checking/kani/tree/main/kani-docs/src/tutorial/kinds-of-failure/"><code>kani-docs/src/tutorial/kinds-of-failure</code></a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Wrap &quot;too-large&quot; indexes back into a valid range for the array
fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    if a.len() == 0 {
        return 0;
    }
    return a[i % a.len() + 1];
}
<span class="boring">}
</span></code></pre></pre>
<p>We can again write a simple property test against this code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    proptest! {
        #[test]
        fn doesnt_crash(i: usize, a: Vec&lt;u32&gt;) {
            get_wrapped(i, &amp;a);
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>This property test will immediately find the failing case because of this dynamic check.</p>
<p>But what if we change this function to use unsafe Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return unsafe { *a.get_unchecked(i % a.len() + 1) };
<span class="boring">}
</span></code></pre></pre>
<p>Now the error becomes invisible to this test:</p>
<pre><code># cargo test
[...]
test tests::doesnt_crash ... ok
</code></pre>
<p>But we're able to check this unsafe code with Kani:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(kani)]
#[kani::proof]
fn bound_check() {
    let size: usize = kani::any();
    kani::assume(size &lt; 4096);
    let index: usize = kani::any();
    let array: Vec&lt;u32&gt; = vec![0; size];
    get_wrapped(index, &amp;array);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code># kani src/bounds_check.rs
[...]
** 1 of 468 failed (2 iterations)
VERIFICATION FAILED
</code></pre>
<p>Notice there were a <em>lot</em> of verification conditions being checked: in the above output, 468! (It may change for you.)
This is a result of using the standard library <code>Vec</code> implementation, which means our harness actually used quite a bit of code, short as it looks.
Kani is inserting a lot more checks than appear as asserts in our code, so the output can be large.
Let's narrow that output down a bit:</p>
<pre><code># kani src/bounds_check.rs | grep FAIL
[get_wrapped.pointer_dereference.5] line 10 dereference failure: pointer outside object bounds in *var_5: FAILURE
VERIFICATION FAILED
</code></pre>
<p>Notice that, for Kani, this has gone from a simple bounds-checking problem to a pointer-checking problem.
Kani will check operations on pointers to ensure they're not potentially invalid memory accesses.
Any unsafe code that manipulates pointers will, as we see here, raise failures if its behavior is actually unsafe. </p>
<p>Consider trying a few more small exercises with this example:</p>
<ol>
<li>Exercise: Switch back to the normal/safe indexing operation and re-try Kani. What changes compared to the unsafe operation and why?
(Try predicting the answer, then seeing if you got it right.)</li>
<li>Exercise: <a href="./tutorial-first-steps.html#getting-a-trace">Remember how to get a trace from Kani?</a> Find out what inputs it failed on.</li>
<li>Exercise: Fix the error, run Kani, and see a successful verification.</li>
<li>Exercise: Try switching back to the unsafe code (now with the error fixed) and re-run Kani. It should still successfully verify.</li>
</ol>
<details>
<summary>Click to see explanation for exercise 1</summary>
<p>Having switched back to the safe indexing operation, Kani reports two failures instead of just one:</p>
<pre><code># kani src/bounds_check.rs | grep FAIL
[get_wrapped.assertion.3] line 9 index out of bounds: the length is move _12 but the index is _5: FAILURE
[get_wrapped.pointer_dereference.5] line 9 dereference failure: pointer outside object bounds in a.data[var_5]: FAILURE
VERIFICATION FAILED
</code></pre>
<p>The first is Rust's implicit assertion for the safe indexing operation.
The second is Kani's check to ensure the pointer operation is actually safe.
This pattern (two checks for similar issues in safe Rust code) is common, and we'll see it again in the next section.</p>
</details>
<details>
<summary>Click to see explanation for exercise 2</summary>
<p>Having run <code>kani --visualize</code> and clicked on one of the failures to see a trace, there are three things to immediately notice:</p>
<ol>
<li>This trace is huge. The standard library <code>Vec</code> is involved, there's a lot going on.</li>
<li>The top of the trace file contains some &quot;trace navigation tips&quot; that might be helpful in navigating the trace.</li>
<li>There's a lot of generated code and it's really hard to just read the trace itself.</li>
</ol>
<p>To navigate this trace to find the information you need, we recommend searching for things you expect to be somewhere in the trace:</p>
<ol>
<li>Search the document for <code>kani::any</code> or <code>variable_of_interest =</code> such as <code>size =</code>.
We can use this to find out what example values lead to a problem.
In this case, where we just have a couple of <code>kani::any</code> values in our proof harness, we can learn a lot just by seeing what these are.
In this trace we find (and the values you get may be different):</li>
</ol>
<pre><code>Step 23: Function bound_check, File src/bounds_check.rs, Line 43
let size: usize = kani::any();
size = 0ul

Step 27: Function bound_check, File src/bounds_check.rs, Line 45
let index: usize = kani::any();
index = 0ul

Step 36: Function bound_check, File src/bounds_check.rs, Line 43
let size: usize = kani::any();
size = 2464ul

Step 39: Function main, File src/bounds_check.rs, Line 45
let index: usize = kani::any();
index = 2463ul
</code></pre>
<p>Try not to be fooled by the first assignments: we're seeing zero-initialization there.
They get overridden by the later assignments.
You may see different values here, as it depends on the solver's behavior.</p>
<ol start="2">
<li>Try searching for &quot;failure:&quot;. This will be near the end of the document.
Now you can try reverse-searching for assignments to the variables involved.
For example, search upwards from the failure for <code>i =</code>.</li>
</ol>
<p>These two techniques should help you find both the nondeterministic inputs, and see what values were involved in the failing assertion.</p>
</details>
<h2 id="overflow-and-math-errors"><a class="header" href="#overflow-and-math-errors">Overflow and math errors</a></h2>
<p>Consider a different variant on the above function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_wrapped(i: usize, a: &amp;[u32]) -&gt; u32 {
    return a[i % a.len()];
}
<span class="boring">}
</span></code></pre></pre>
<p>We've corrected the out-of-bounds access, but now we've omitted the &quot;base case&quot;: what to return on an empty list.
Kani will spot this not as a bound error, but as a mathematical error: on an empty list the modulus operator (<code>%</code>) will cause a division by zero.</p>
<ol>
<li>Exercise: Try to run Kani on the above, to see what this kind of failure looks like.</li>
</ol>
<p>Rust also performs runtime safety checks for integer overflows, much like it does for bounds checks.
Consider this code (from <code>src/overflow.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn simple_addition(a: u32, b: u32) -&gt; u32 {
    return a + b;
}
<span class="boring">}
</span></code></pre></pre>
<p>A trivial function, but if we write a property test for it, we immediately find inputs where it fails, thanks to Rust's dynamic checks.
Kani will find these failures as well.
Here's the output from Kani:</p>
<pre><code># kani src/overflow.rs
[...]
** Results:
./src/overflow.rs function simple_addition
[simple_addition.assertion.1] line 6 attempt to compute `move _3 + move _4`, which would overflow: FAILURE
[simple_addition.overflow.1] line 6 arithmetic overflow on unsigned + in var_3 + var_4: FAILURE

** 2 of 2 failed (2 iterations)
VERIFICATION FAILED
</code></pre>
<p>Notice the two failures: the Rust-inserted overflow check (<code>simple_addition.assertion.1</code>) and Kani's explicit overflow check (<code>simple_addition.overflow.1</code>).</p>
<blockquote>
<p><strong>NOTE:</strong> You could attempt to fix this issue by using Rust's alternative mathematical functions with explicit overflow behavior.
For instance, instead of <code>a + b</code> write <code>a.wrapping_add(b)</code>.</p>
<p>However, <a href="https://github.com/model-checking/kani/issues/480">at the present time</a>, while this disables the dynamic assertion that Rust inserts, it does not disable the additional Kani overflow check.
As a result, this currently still fails in Kani.</p>
</blockquote>
<h3 id="exercise-classic-overflow-failure"><a class="header" href="#exercise-classic-overflow-failure">Exercise: Classic overflow failure</a></h3>
<p>One of the classic subtle bugs that persisted in many implementations for a very long time is finding the midpoint in quick sort.
This often naively looks like this (from <code>src/overflow_quicksort.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_midpoint(low: u32, high: u32) -&gt; u32 {
    return (low + high) / 2;
}
<span class="boring">}
</span></code></pre></pre>
<p>Kani immediately spots the bug in the above code.</p>
<ol>
<li>Exercise: Fix this function so it no longer overflows.
(Hint: depending on which approach you take, you may need to add the assumption that <code>high &gt; low</code> to your proof harness.
Don't add that right away, see what happens if you don't. Just keep it in mind.)</li>
<li>Exercise: Prove your new implementation actually finds the midpoint correctly by adding an assertion to the test harness.</li>
</ol>
<details>
<summary>Click to see solutions for these exercises</summary>
<p>A very common approach for resolving the overflow issue looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return low + (high - low) / 2;
<span class="boring">}
</span></code></pre></pre>
<p>But if you naively try this (try it!), you'll find a new underflow error: <code>high - low</code> might result in a negative number, but has type <code>u32</code>.
Hence, the need to add an assumption that would make that impossible.
(Adding an assumption, though, means there's a new way to &quot;use it wrong.&quot; Perhaps we'd like to avoid that!)</p>
<p>After that, you might wonder how to &quot;prove your new implementation correct.&quot;
After all, what does &quot;correct&quot; even mean?
Often we're using a good approximation of correct, such as the equivalence of two implementations (often one much &quot;simpler&quot; than the other somehow).
Here's one possible assertion to make that obvious:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(result as u64 == (a as u64 + b as u64) / 2);
<span class="boring">}
</span></code></pre></pre>
<p>Since this implementation is just the original one, but cast to a wider unsigned integer type, it should have the same result but without overflowing.
When Kani tells us both of these methods yield the same exact result, that gives us additional confidence that we haven't overlooked something.</p>
</details>
<h2 id="future-work"><a class="header" href="#future-work">Future work</a></h2>
<p>Kani notably does not currently check the following:</p>
<ol>
<li>
<p>Concurrency bugs, deadlocks, or data races.
It's possible Kani may be extended in the future to find such issues.</p>
</li>
<li>
<p>Rust type invariants.
For example, it's undefined behavior in Rust to produce a value of type <code>bool</code> that isn't <code>0</code> or <code>1</code>.
Kani will not spot this error (in presumably unsafe code), yet.</p>
</li>
<li>
<p>Fully generic functions.
To write a proof harness and call functions, they must be fully &quot;monomorphized.&quot;
This means we can't currently check a generic function (<code>foo&lt;T&gt;</code>) generically.
Proof harnesses have to be written specializing type parameters (<code>T</code>) to concrete types (e.g. <code>u32</code>), and check those instead.</p>
</li>
</ol>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this section:</p>
<ol>
<li>We saw Kani spot potential bounds check errors.</li>
<li>We saw Kani spot actually-unsafe dereferencing of a raw pointer to invalid memory.</li>
<li>We saw Kani spot a division by zero error.</li>
<li>We saw Kani spot overflowing addition.</li>
<li>As an exercise, we tried proving an assertion (finding the midpoint) that was not completely trivial.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="tutorial-first-steps.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="tutorial-loops-unwinding.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="tutorial-first-steps.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="tutorial-loops-unwinding.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
